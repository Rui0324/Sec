---
tags:
  - 逆向
---
  - 编译器和IDE环境（集成开发环境）区分
  - 这里学习C是为了啃透，所以建议使用VC6，在VC6中内存结构相对简单，VS2019/2022在此基础上添加了一点安全元素（防止栈溢出），使用VS2019/2022会产生知识结构依赖的递归问题
  
# Hello World！

## 编译链接代码
- 下载VC6，添加环境变量，这里不仅要添加两个bin目录，还需要在变量中添加INCLUDE、LIB两个变量，如果不添加后面两个变量，就会导致cl编译器虽然能正常执行，但是在编译代码的时候无法找到头文件，部分VC6的安装包在安装时会有添加到环境变量的选项，如果勾选则不需要手动添加INCLUDE、LIB两个变量（一般不建议手动添加）
	- 变量名：INCLUDE，值：C:\Apps\Microsoft Visual Studio\VC98\Include;C:\Apps\Microsoft Visual Studio\VC98\MFC\Include;C:\Apps\Microsoft Visual Studio\VC98\ATL\Include
	- 变量名：LIB，值：C:\Apps\Microsoft Visual Studio\VC98\Lib;C:\Apps\Microsoft Visual Studio\VC98\MFC\Lib
	- 变量名：PATH，值：（在原有 PATH 前面追加）C:\Apps\Microsoft Visual Studio\VC98\Bin;C:\Apps\Microsoft Visual Studio\Common\MSDev98\Bin;
- 这里的路径根据安装的实际情况而定
- 创建一个文本文档，将后缀名改为`.c`，使用个人喜欢的文本编辑器编写代码
```
#include<stdio.h>

int main()
{
	printf("Hello World!\r\n");
	return 0;
}
```
- 在代码文件所在目录的cmd，输入指令`cl /c hello.c`编译程序，只显示hello.c代表编译成功![[HelloWorld-1.png]]
- `/c`表示仅编译不链接，不将编译和链接一起完成的原因
	- 在这里需要详细了解编译链接每一步是干嘛的
	- 实战中可能存在多个源码文件，挨个编译，统一链接
- 如果编译失败，会出现提示，比如这里将代码修改为
```
#include<stdio.h>
int main()
{
	printf3("Hello World!\r\n");
	return 0;
}
```
- 将刚刚编译成功的hello.obj文件删除，再次编译，发现也编译通过了，这是因为检查力度不够的原因
- 输入命令`cl /c /W4 hello.c`
- `/W1-4`表示选择警告等级，默认是一级警告，这里直接选择4级警告，这里正常报错![[HelloWorld-2.png]]
- 即使编译时不报错，但在链接时是依旧会报错，会报告找不到这个符号![[HelloWorld-3.png]]
- 虽然将警告等级调为`W4`，但是依旧定义为警告没有定义为错误，所以这还是会传递，可以在命令中加入`/WX`
- `/WX`代表将警告视为错误
- 输入`cl /c /W4 /WX hello.c`，发现错误警告，不会产生`.obj`文件![[HelloWorld-4.png]]
- PS：`/W4`四级警告有一个不好的地方是，如果在代码中定义了一个变量但是没有使用它，它也会产生警告，所以建议正常使用`/W3`三级警告就好

- 回到正题，正常编译产生`.obj`文件，链接`.obj`文件产生可执行文件![[HelloWorld-5.png]]
- 执行一下，看功能是否正确
  ![[HelloWorld-6.png]]
- 返回`Hello World`，功能正常

### .obj文件
- `obj`是一个标准，和语言无关，在以前16位的时候有一套，现在的标准是COFFF；obj的优点就是可以跨语言平台的

### .exe可执行文件
- 虽然有数据机器代码obj文件都有了，但这时的机器代码是不可以直接执行的，因为需要满足这个操作系统执行文件的格式，这种格式叫做PE格式。抽取obj中代码、数据以及其他的一些必要信息，然后按照windows里面所要求的可执行文件格式放入到代码应该所在的位置，数据放到数据应该在的位置以及其他的一些必要信息，分门别类的放到windows所要求的位置，这个时候才可以执行


## 代码运行详解
```
#include<stdio.h>

int main()
{
	printf("Hello World!\r\n");
	return 0;
}
```

### include<stdio.h>
- `inlcude`是标准头文件，首先到环境变量include中，到这些路径中寻找文件名，如果环境变量中没有，就会在源码所在的路径下面再找一次![[HelloWorld-7.png]]
- 手动找到`stido.h`的文件，使用记事本打开![[HelloWorld-8.png]]
- 将`stdio.h`中的内容手动替换`#include<stdio.h>`编译的效果也是一样的，这里替换之后删除之前编译链接的文件，重新编译链接运行代码，没有问题![[HelloWorld-9.png]]
- **不检查扩展名**，在源文件下创建一个`abc.txt`文件，在里面输入`int g_nTest = 1234;`，甚至可以更夸张一点，将文件扩展名改位`.bmp`，然后将代码修改，重新编译链接运行
- 这里为什么使用双引号，不是尖括号也可以找到吗？这是因为使用尖括号就默认是官网所有的头文件，使用双引号就默认是自己做的头文件，这就会使读你源码的人认为是官方提供的，就会默认你的正确性，这对排bug是不利的，所以自己做的源码头文件使用双引号，这是江湖规矩也是代码规范要求![[HelloWorld-10.png]]
- 还可以看他include后（预处理后）的结果，输入指令编译查看预处理结果`cl /c /P hello.c`，之后本地会产生一个`.i`文件![[HelloWorld-11.png]]
- 这个文档里面都是一些说明性信息，文档不能够再次编译，如图所示预处理结果![[HelloWorld-12.png]]
- 但是头文件文档虽然不限制格式，但是不要随便瞎写；一般默认`xxxxxx.hpp`是c++的头文件，或者`xxxxxx.hxx`h后面为某项目的缩写，**不要使用人名缩写**，在公司团队工作中，比较忌讳留下一些个人话的东西，不利于团队整体；但每个团队实际情况可能有所不同，所以根据团队实际情况来定
- 回到上面`cl /c /P hello.c`，这是一个冷门的编译选项，而且在老版本的ide上面很少有这个选项，新的ide界面上根本没有的给你选

### main开始
- 第三行代码就是main函数
- 以VC6为例，程序目录在安装路径下的VC98中的CRT，找到SRC（源码文件），里面有各种C库的实现代码，例如随机数是怎么算出来的，对于新手学习很友好![[HelloWorld-13.png]]
- 找到`CRT0.C`，泛读代码，精读工作量太大，找到程序的入口点，根据编译模式，有四种入口点之一![[HelloWorld-14.png]]
- 窗口程序以`win`开头，控制台程序以`main`开头，然后是单字节一个字符还是个双字节一个字符，双字节一个字符也就是宽字节Unicode编码，前面会有一个`w`（小写）
- helloworld的程序入口点是`mainCRTStartup`，在这个入口点里面会先获取到当前的操作系统版本![[HelloWorld-15.png]]
- 然后区分单线程环境和多线程环境并进行初始化，如果是多线程环境要先初始化多线程环境 `_mtinit()`再初始化 io系统`_ioinit()`，如果io没有初始化会使`stdin`、`stdout`和`stderr`崩溃或行为异常![[HelloWorld-16.png]]
- 获取并格式化命令行和环境变量，用户在命令行输入的指令（如 `cl /c hello.c`）是以空格分隔的单个字符串。而C语言标准要求程序通过字符型指针数组 `argv` 来接收这些参数，所以需要获取并格式化命令行和环境变量并按照c语言标准把它门变为字符型指针数组![[HelloWorld-17.png]]
- 之后做全局初始化的动作![[HelloWorld-18.png]]
- 初始化之后获取当前进程的基本环境![[HelloWorld-19.png]]
- 然后这才调到main函数了，四个函数调其一，并且传递三个参数![[HelloWorld-20.png]]

### printf
- 建议安装MSDN打开查看printf，打开之后可以看到printf的简介、参数和返回值的声明、包含的头文件、支持的环境、个参数的说明、备注、例子、例子的输出结果、相关分和信息、同类型近义词或反义词![[HelloWorld-21.png]]
- 可以在备注中找到格式化说明![[HelloWorld-22.png]]
- 格式化分为一下几个部分，%类型这一部分![[HelloWorld-23.png]]
- 类型是我们常见的`%c`、`%d`、`%a`有详细的说明![[HelloWorld-24.png]]
- 第二方面是可选类型，比如说短整型、长整型![[HelloWorld-25.png]]
- 但是在有些软件中是有区别的，比如使用`sizeof`测试一下长整型`long int`![[HelloWorld-26.png]]
- 重新编译链接，执行；这里会显示是四字节，在别的编译器中有效，在微软的编译器中无效![[HelloWorld-27.png]]
- 如果将`long int`改为`__int64`就会显示为八字节![[HelloWorld-28.png]]
- 这是因为微软编译器 (MSVC) 遵循的是 Windows 下的LLP64数据模型，而不是 Linux/Unix 常见的LP64数据模型
- 所以当你用的标准不一样的时候，尽量的使用C标准语法去完成，不然做出来的产品以后只能做微软，难以跨平台
- 但C语言的优点是什么，是**跨平台**，C语言是美国国标，这个国标规定了每个语法改怎么做，什么功能，做这个编译器的人要遵循满足C标准去实现这个编译器，按照C语言的设想，你在a编译器上写的某个算法，只要是C源码可以移植到别的C编译器上可以编译通过，并且值不变
- 算法和数据结构类的具有很强的可移植性，所以需要规范书写，来规避这种语法特性，规避ABI的语法元素，而且ABI很多语法元素让人用的很舒服，除了不好移植其他都行
- 想要输出正确的整型值，需要加后缀；比如长整型，常量后面加`L`就是长整型常量![[HelloWorld-29.png]]
- 若如上图输出就会得到`87654321`，`%x`是输出十六进制的数![[HelloWorld-30.png]]
- 如果加上`I64`那么就会输出`1234567887654321`![[HelloWorld-31.png]]
- 补充：`3.14`是双精度浮点常量，加`f`变为`3.14f`是单精度常量
- 下面再看精度部分，告诉格式化和输出的时候精度是多少![[HelloWorld-32.png]]
- 这里换成浮点数![[HelloWorld-33.png]]![[HelloWorld-34.png]]
- 在`f`前加上`.2`表示小数点后保留两位![[HelloWorld-35.png]]
- 下面是宽度部分![[HelloWorld-36.png]]
- 比如说一个整型123![[HelloWorld-37.png]]
- 如果输出的内容较多，想要将它排列整齐；比如在代码中加入一个循环![[HelloWorld-38.png]]
- 可以看到代码不整齐的情况，如果想要整齐可以将`%d`改为`%3d`，因为最大就是三位数，这样哪怕就只有一位数，输出宽度也为3![[HelloWorld-39.png]]
- 不想前面是空格使用0填充那么改为`%03d`![[HelloWorld-40.png]]
- 这个前面并不可以随便填写，只有四个值可以选择![[HelloWorld-41.png]]
- 直接使用`printf`是时候直接输入`hello`就可以了，用大于号`>`输出重定向，输出重定向到想要的新地方，这个新地方可以是网络、磁盘等
- 比如这里输入`hello > hello.txt`，回车之后发现下面什么都没有，但是文件夹中出现了一个`hello.txt`的文件，打开这个文件就发现它将控制台内容输出为文件了![[HelloWorld-42.png]]
- `<`表示将文件内容作为程序的标准输入，而不是让程序从键盘输入
- 标准输入设备（stdin），标准输出设备（stdout）都是支持重定向的
- 还有一类是不支持重定向的，叫做`stderr`
- 这里参数如果写为`stdout`，输出结果就和`printf`一摸一样，这个函数可以指定哪里格式化输出![[HelloWorld-43.png]]
- 将`stdout`修改为`stderr`（标准错误对象），重新编译链接![[HelloWorld-45.png]]
- 控制台输出了结果，txt文件产生了，但是是空白的![[HelloWorld-46.png]]
- `stderr`长用于显示器显示错误信息，但不支持重定向

### main结束
- 但这里`mian`函数就结束了，标准函数`exit`，`mian`函数的返回做`exit`函数的返回值，然后`exit`做进程的返回值，main函数的返回值决定进程的返回值
- 当`exit`实现之后会标明一个`Windows API`叫做`ExitProcess`，然后参数填`mainret`或者是mainret参数的传递，传递给其他变量名的，里面的函数做全局对象的释放工作![[HelloWorld-47.png]]


- 整体的代码大概就是这个样子
- 高版本的道理一样，但代码可读性高版本的代码没有低版本的好，低版本的SRC非常详细，注释比代码还要多







# RAND（随机数）
- 上面提到随机数的计算，这里分析一下`RAND`函数![[RAND-1.png]]
- `rand`分为多线程和单线程的
- 多线程可以不用理会，多线程相当于一个管理机制，获得一个值
- 单线程就是一个全局变量`holdrand`，这个全局变量的初始是1，称之为种子值![[RAND-2.png]]
- 每次rand的时候就会乘以一个常量在加上一个常量，再往右移动16位，最后抛弃高位留低15位，然后这个值还会写回去，更新全局变量的值![[RAND-3.png]]
- 这样我们调用就是是一个看似随机实际固定的序列
- 示例代码
```
#include<stdio.h>

int main()
{
        int n = 1;

        for(; n <= 10; n++)
        {
                printf("%d\n\r", rand());
        }

        return 0;
}
```
- 再写一个编译脚本，创建一个文本文件，将后缀名改为`.bat`
```
del *.exe                   //删除所有.exe文件
del *.obj                   //删除所有.obj文件
cl /c /W3 /WX hello.c
link hello.obj
pause                       //暂停
hello.exe
pause
```
- 双击运行，发现这里提示`rand`没有被定义，说明没有包含头文件![[RAND-4.png]]
- 记不得头文件，直接使用MSDN，无需刻意背诵记忆，MSDN会告诉是哪里定义的![[RAND-5.png]]
- MSDN中还存在例子，可以直接复制粘贴，修改代码之后再次运行编译脚本![[RAND-6.png]]
- 这里只能看到一次，到命令行中多看几次，会发现没有随机![[RAND-7.png]]
- 所以官方给出的解决方案是`srand`加`time`![[RAND-8.png]]
- 再次阅读一下`srand`的代码，`srand`代码是全局变量赋值的意思，因为这个种子数就是一个全局变量![[RAND-9.png]]![[RAND-10.png]]
- 后面又使用了一个`time`函数，获得系统时间![[RAND-11.png]]
- 可以看msdn的例子，调用time函数之后会返回1970年1月1日至今的秒数，这时就存在一定的随机性![[RAND-12.png]]
- 很多情况下会将这个秒数赋值给全局变量作为初值，然后由全局变量完成后面固定的运算![[RAND-13.png]]
- 在源代码中加入一行代码，注意，不能将srand加入到循环当中，放入循环当中是无法达到随机效果的
```
srand( (unsigned)time( NULL ) );
```
- 重新编译链接，这里报错无法识别time函数，原因是没有包含头文件![[RAND-14.png]]
- 查看time所需要的头文件，并且看一下标准`ANSI`美国国标的缩写，没有这个缩写就是微软自己的函数，换个环境能不能用就不知道了，比如说典型的`_beginthread`就没有标准![[RAND-15.png]]![[RAND-16.png]]
- 回到源码加上`time`的头文件，重新编译链接，没有发现错误，但是发现随机的数字都是一样的![[RAND-17.png]]
- 原因是循环内速度极快，一秒内会有多次循环。将`srand`函数移到外面之后，再次编译链接，发现数字发生改变![[RAND-18.png]]
- 但是重要操做不要使用`rand`函数，操作系统的特性该用还是要用，微软提供了一组大数计算库里面有高精度随机数产生器；`rand`函数产生的随机数还是存在问题的，它的算法是固定的，它的随机数序列只有三万多种