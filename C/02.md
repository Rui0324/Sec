#逆向 

# 有关内存
- 在冯诺依曼模型的电脑中负责计算的是处理器，硬盘负责存储
- PS：硬盘是不可靠的存储，可靠的存储是磁带和光盘，目前某些重要场合还在使用，比如医院和银行
- 冒泡算法在磁带机上的效率是最高的，磁带机是不支持随机访问的，它是一个顺序存储，比如你要听第n首歌，就需要转掉n-1首歌，n越大代价越大，是一个线性代价；后来开始使用CD光盘，使用光盘听n首歌的代价是均匀的，光盘支持随机访问
- 磁带机有优点--海量存储且廉价还可靠
- 关于存储的四个性能：可靠性，稳定性，访问快，存储量大
- 正常使用的硬盘相比下支持随机访问但不那么可靠稳定，磁带机从高处坠落、泡水，捡起来还是可以继续使用，但是硬盘不可以
- 磁盘的工作原理是刚性磁片，刚性磁片里面的磁头跟它访问，磁头有两个工作，给它磁力线过阈值，由磁生电，由电区分0和1，所以磁盘一般最怕温差
- 磁带相对便宜，但是访问起来太慢了；所以大多数娱乐用户会选择硬盘，如果工作比较重要就会隔三岔五的进行备份，因为不信任磁盘，它不是那么的可靠
- 解决了存储问题，硬盘存储量大，可靠也够正常用户使用，现在的问题是磁盘是一个机械设备访问慢，但是处理器解决问题的能力远超于硬盘提供问题的能力，这里的硬盘也就是冯诺依曼模型中的存储器，处理器长时间等待硬盘，整体的架构效率就跟硬盘走；这就好比去吃一碗拉面，拉面师傅做一碗拉面要十分钟，吃一碗拉面只要两分钟，请问吃五碗拉面要多久？所以时间以速度慢的算，如何解决这个问题，提高效率，拉面师傅做好拉面放在桌子上，要吃几万拉面自己拿，这样整体架构上面就变快了，拉面师傅不管你吃几碗，什么时候吃，只要有时间就做拉面放在桌子上，这张桌子就起到内存的作用
- 在桌子上放面条每碗面条要给编号，不然读和写不知道访问哪一个，就直接使用数字化给编号就好了；早期计算机体系结构中，由于存储器里面存储不海量，会给存储区域起名字；但现在相比早期的结构是海量的，所以无法取名，这个时候就只能给编号
- 32位程序的理论寻址是0x00000000~0xFFFFFFFF，这八个0到八个F里面存放的空间，一个编号代表一个存储的字节单位，这个编号被称作内存地址，英文翻译有两个命名一个是address，一个是point，因为内存相比内存地址上的一个数据来说是一个线和点的关系
- `scanf`面临一个问题，它是格式化，首先从标准输入里面读取数据，按照格式化要求经过格式化之后送达某个存储单元去，想送到某个存储单元去就必须要知道存储单元的地址，所以`scanf`是必须要提供地址的，不提供地址没有办法工作，而`printf`是不需要的，它只需要提供值，把某个值格式化输出到标准输出设备







# Scanf
```
#include<stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
        int n = 1;
        
        printf("%08x\r\n", &n);
        scanf("%d", &n);
        system("pause");

        return 0;
}
```
- 直接使用之前的脚本完成编译链接运行，这里会显示一个地址`0019ff2c`![[Scanf-1.png]]
- 出现这个地址片段就说明是win10的栈地址，操作系统就直接暴露了；win7是0018开头，xp很大概率是0012开头；这个地址暴露出来之后存在安全隐患，所以在后来的编译器中就提供了地址随机化的选项，让懂内存的人无法判断
- 使用VC6开始学习，在读懂内存结构之后，哪怕随机了，只要定位到它的位置，里面的结构是和低版本一样的，只是在起点位置发生了随机，后面一概不变